"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.once = exports.on = exports.off = exports.create = exports.createAsync = exports.createSync = void 0;
function createSync() {
    var isUsingList = false;
    var signal = function () {
        isUsingList = true;
        try {
            var snapshot = signal.list;
            var length = snapshot.length;
            for (var i = 0; i < length; ++i) {
                snapshot[i].apply(this, arguments);
            }
        }
        finally {
            isUsingList = false;
        }
    };
    signal.list = [];
    signal.lock = function () {
        if (isUsingList) {
            signal.list = signal.list.slice();
            isUsingList = false;
        }
    };
    return signal;
}
exports.createSync = createSync;
function isPromise(obj) {
    return obj && typeof obj.then === 'function';
}
function parallel(thisArg, handlers, args) {
    return new Promise(function (resolve, reject) {
        var pending = 0;
        var fulfill = function () {
            if (--pending === 0) {
                resolve();
            }
        };
        var length = handlers.length;
        for (var index = 0; index < length; ++index) {
            var result = handlers[index].apply(thisArg, args);
            if (isPromise(result)) {
                ++pending;
                result.then(fulfill, reject);
            }
        }
    });
}
function serial(thisArg, handlers, args) {
    return new Promise(function (resolve, reject) {
        var length = handlers.length;
        var index = 0;
        var next = function () {
            if (index >= length) {
                resolve();
                return;
            }
            var result = handlers[index++].apply(thisArg, args);
            if (isPromise(result)) {
                result.then(next, reject);
            }
            else {
                next();
            }
        };
        next();
    });
}
function createAsync(options) {
    var isUsingList = false;
    var strategy = options && options.parallel ? parallel : serial;
    var signal = function () {
        isUsingList = true;
        return strategy(this, signal.list, arguments).finally(function () {
            isUsingList = false;
        });
    };
    signal.list = [];
    signal.lock = function () {
        if (isUsingList) {
            signal.list = signal.list.slice();
            isUsingList = false;
        }
    };
    return signal;
}
exports.createAsync = createAsync;
function create(options) {
    if (options === void 0) { options = {}; }
    return options.async
        ? createAsync(options)
        : createSync();
}
exports.create = create;
function off(signal, handler) {
    var list = signal.list;
    if (handler === undefined) {
        if (list.length === 0) {
            return false;
        }
        signal.lock();
        signal.list = [];
        return true;
    }
    var index = list.length - 1;
    while (index >= 0) {
        var wrapped = list[index];
        if (wrapped === handler || wrapped.inner === handler) {
            break;
        }
        --index;
    }
    if (index !== -1) {
        signal.lock();
        signal.list.splice(index, 1);
        return true;
    }
    return false;
}
exports.off = off;
function on(signal, handler, options) {
    if (options === void 0) { options = {}; }
    var wrapped = handler;
    if (options && options.once) {
        wrapped = function () {
            off(signal, handler);
            return handler.apply(null, arguments);
        };
        wrapped.inner = handler;
    }
    signal.lock();
    signal.list.push(wrapped);
}
exports.on = on;
function once(signal, handler) {
    on(signal, handler, { once: true });
}
exports.once = once;
