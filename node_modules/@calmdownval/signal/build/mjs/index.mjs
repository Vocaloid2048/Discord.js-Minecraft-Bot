export function createSync() {
    let isUsingList = false;
    const signal = function () {
        isUsingList = true;
        try {
            const snapshot = signal.list;
            const length = snapshot.length;
            for (let i = 0; i < length; ++i) {
                snapshot[i].apply(this, arguments);
            }
        }
        finally {
            isUsingList = false;
        }
    };
    signal.list = [];
    signal.lock = () => {
        if (isUsingList) {
            signal.list = signal.list.slice();
            isUsingList = false;
        }
    };
    return signal;
}
function isPromise(obj) {
    return obj && typeof obj.then === 'function';
}
function parallel(thisArg, handlers, args) {
    return new Promise((resolve, reject) => {
        let pending = 0;
        const fulfill = () => {
            if (--pending === 0) {
                resolve();
            }
        };
        const length = handlers.length;
        for (let index = 0; index < length; ++index) {
            const result = handlers[index].apply(thisArg, args);
            if (isPromise(result)) {
                ++pending;
                result.then(fulfill, reject);
            }
        }
    });
}
function serial(thisArg, handlers, args) {
    return new Promise((resolve, reject) => {
        const length = handlers.length;
        let index = 0;
        const next = () => {
            if (index >= length) {
                resolve();
                return;
            }
            const result = handlers[index++].apply(thisArg, args);
            if (isPromise(result)) {
                result.then(next, reject);
            }
            else {
                next();
            }
        };
        next();
    });
}
export function createAsync(options) {
    let isUsingList = false;
    const strategy = options && options.parallel ? parallel : serial;
    const signal = function () {
        isUsingList = true;
        return strategy(this, signal.list, arguments).finally(() => {
            isUsingList = false;
        });
    };
    signal.list = [];
    signal.lock = () => {
        if (isUsingList) {
            signal.list = signal.list.slice();
            isUsingList = false;
        }
    };
    return signal;
}
export function create(options = {}) {
    return options.async
        ? createAsync(options)
        : createSync();
}
export function off(signal, handler) {
    const { list } = signal;
    if (handler === undefined) {
        if (list.length === 0) {
            return false;
        }
        signal.lock();
        signal.list = [];
        return true;
    }
    let index = list.length - 1;
    while (index >= 0) {
        const wrapped = list[index];
        if (wrapped === handler || wrapped.inner === handler) {
            break;
        }
        --index;
    }
    if (index !== -1) {
        signal.lock();
        signal.list.splice(index, 1);
        return true;
    }
    return false;
}
export function on(signal, handler, options = {}) {
    let wrapped = handler;
    if (options && options.once) {
        wrapped = function () {
            off(signal, handler);
            return handler.apply(null, arguments);
        };
        wrapped.inner = handler;
    }
    signal.lock();
    signal.list.push(wrapped);
}
export function once(signal, handler) {
    on(signal, handler, { once: true });
}
