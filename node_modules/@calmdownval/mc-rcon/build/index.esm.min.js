import{create as t,on as e,once as i,off as n}from"@calmdownval/signal";import{Socket as o}from"net";function s(t,e,i,n){return new(i||(i=Promise))((function(o,s){function r(t){try{d(n.next(t))}catch(t){s(t)}}function c(t){try{d(n.throw(t))}catch(t){s(t)}}function d(t){var e;t.done?o(t.value):(e=t.value,e instanceof i?e:new i((function(t){t(e)}))).then(r,c)}d((n=n.apply(t,e||[])).next())}))}function r(t){if(!t.isConnected)throw new Error("RConSocket not connected")}var c,d;!function(t){t[t.AUTH=3]="AUTH",t[t.COMMAND=2]="COMMAND",t[t.COMMAND_TX=100]="COMMAND_TX"}(c||(c={})),function(t){t[t.AUTH=2]="AUTH",t[t.COMMAND=0]="COMMAND"}(d||(d={}));let a=0;function h(){return 65535*Math.random()<<15|(a=32767&++a)}class u{constructor(){this.socket=new o,this.error=t(),this.message=t(),this._isConnected=!1,this._isDrained=!0,this.onClose=()=>{this._isConnected=!1},this.onData=t=>{let e;this._data=this._data?Buffer.concat([this._data,t]):t;try{e=function(t){const e=t.readInt32LE(0);if(t.length!==e+4||0!==t.readInt16LE(e+2))throw new Error("invalid packet length");return{id:t.readInt32LE(4),kind:t.readInt32LE(8),payload:t.toString("ascii",12,e+2)}}(this._data),this._data=void 0}catch(t){return}this.message(e)},this.onDrain=()=>{this._isDrained=!0},this.socket.on("close",this.onClose).on("data",this.onData).on("drain",this.onDrain).on("error",this.error)}get isConnected(){return this._isConnected}connect(t,e=25575){return s(this,void 0,void 0,(function*(){return function(t){if(t.isConnected)throw new Error("RConSocket already connected")}(this),new Promise(((i,n)=>{this.socket.connect({host:t,port:e}).on("error",n).once("connect",(()=>{this.socket.off("error",n),this._isConnected=!0,i()}))}))}))}close(){return this._isConnected?new Promise((t=>this.socket.end(t))):Promise.resolve()}send(t){return s(this,void 0,void 0,(function*(){r(this),yield this.drain(),yield this.write(function({id:t,kind:e,payload:i}){const n=Buffer.byteLength(i,"ascii")+14,o=Buffer.allocUnsafe(n);return o.writeInt32LE(n-4,0),o.writeInt32LE(t,4),o.writeInt32LE(e,8),o.write(i,12,"ascii"),o.writeInt16LE(0,n-2),o}(t))}))}receive(t,o={}){return s(this,void 0,void 0,(function*(){return r(this),new Promise(((s,r)=>{let c;const d=()=>{clearTimeout(c),n(this.message,a)},a=e=>{e.id===t&&(d(),s(e))};e(this.message,a);const{cancel:h,timeout:u=5e3}=o;h&&i(h,d),u>0&&(c=setTimeout((()=>{d(),r(new Error("receive timed out"))}),u))}))}))}drain(){return this._isDrained?Promise.resolve():new Promise((t=>{this.socket.once("drain",t)}))}write(t){return new Promise(((e,i)=>{this._isDrained=this.socket.write(t,(t=>{t?i(t):e()}))}))}}class l{constructor(){this.socket=new u,this._isLoggedIn=!1,this.timeout=5e3}get isConnected(){return this.socket.isConnected}get isLoggedIn(){return this._isLoggedIn}connect(t,e){return this.socket.connect(t,e)}close(){return this.socket.close()}login(e){return s(this,void 0,void 0,(function*(){r(this.socket),function(t){if(t.isLoggedIn)throw new Error("Client already logged in")}(this);const i=h(),n={cancel:t(),timeout:this.timeout},o=[this.socket.receive(-1,n),this.socket.receive(i,n)];this.socket.send({id:i,kind:c.AUTH,payload:e});const s=yield Promise.race(o);if(n.cancel(),-1===s.id)throw new Error("invalid password");this._isLoggedIn=!0}))}exec(t){return s(this,void 0,void 0,(function*(){r(this.socket),function(t){if(!t.isLoggedIn)throw new Error("Client not logged in")}(this);const i=h(),n=h();let o="";return e(this.socket.message,(t=>{t.id===i&&(o+=t.payload)})),this.socket.send({id:i,kind:c.COMMAND,payload:t}),this.socket.send({id:n,kind:c.COMMAND_TX,payload:""}),yield this.socket.receive(n,{timeout:this.timeout}),o}))}}export{l as Client,u as RConSocket};
